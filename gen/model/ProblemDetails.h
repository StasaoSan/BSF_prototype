/**
 * Nbsf_Management
 * Binding Support Management Service API.    © 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).    All rights reserved.  
 *
 * The version of the OpenAPI document: 1.3.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.7.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * ProblemDetails.h
 *
 * Provides additional information in an error response.
 */

#ifndef ProblemDetails_H_
#define ProblemDetails_H_



#include <string>
#include "InvalidParam.h"
#include "AccessTokenErr.h"
#include "AccessTokenReq.h"
#include <vector>
#include <memory>
#include <vector>
#include <boost/property_tree/ptree.hpp>
#include "helpers.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

/// <summary>
/// Provides additional information in an error response.
/// </summary>
class  ProblemDetails 
{
public:
    ProblemDetails() = default;
    explicit ProblemDetails(boost::property_tree::ptree const& pt);
    virtual ~ProblemDetails() = default;

    ProblemDetails(const ProblemDetails& other) = default; // copy constructor
    ProblemDetails(ProblemDetails&& other) noexcept = default; // move constructor

    ProblemDetails& operator=(const ProblemDetails& other) = default; // copy assignment
    ProblemDetails& operator=(ProblemDetails&& other) noexcept = default; // move assignment

    std::string toJsonString(bool prettyJson = false) const;
    void fromJsonString(std::string const& jsonString);
    boost::property_tree::ptree toPropertyTree() const;
    void fromPropertyTree(boost::property_tree::ptree const& pt);


    /////////////////////////////////////////////
    /// ProblemDetails members

    /// <summary>
    /// String providing an URI formatted according to RFC 3986.
    /// </summary>
    std::string getType() const;
    void setType(std::string value);

    /// <summary>
    /// 
    /// </summary>
    std::string getTitle() const;
    void setTitle(std::string value);

    /// <summary>
    /// 
    /// </summary>
    int32_t getStatus() const;
    void setStatus(int32_t value);

    /// <summary>
    /// A human-readable explanation specific to this occurrence of the problem.
    /// </summary>
    std::string getDetail() const;
    void setDetail(std::string value);

    /// <summary>
    /// String providing an URI formatted according to RFC 3986.
    /// </summary>
    std::string getInstance() const;
    void setInstance(std::string value);

    /// <summary>
    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available. 
    /// </summary>
    std::string getCause() const;
    void setCause(std::string value);

    /// <summary>
    /// 
    /// </summary>
    std::vector<InvalidParam> getInvalidParams() const;
    void setInvalidParams(std::vector<InvalidParam> value);

    /// <summary>
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \&quot;0\&quot; to \&quot;9\&quot;,  \&quot;a\&quot; to \&quot;f\&quot; or \&quot;A\&quot; to \&quot;F\&quot; and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported. 
    /// </summary>
    std::string getSupportedFeatures() const;
    void setSupportedFeatures(std::string value);

    /// <summary>
    /// 
    /// </summary>
    AccessTokenErr getAccessTokenError() const;
    void setAccessTokenError(AccessTokenErr value);

    /// <summary>
    /// 
    /// </summary>
    AccessTokenReq getAccessTokenRequest() const;
    void setAccessTokenRequest(AccessTokenReq value);

    /// <summary>
    /// Fully Qualified Domain Name
    /// </summary>
    std::string getNrfId() const;
    void setNrfId(std::string value);

protected:
    std::string m_Type = "";
    std::string m_Title = "";
    int32_t m_Status = 0;
    std::string m_Detail = "";
    std::string m_Instance = "";
    std::string m_Cause = "";
    std::vector<InvalidParam> m_InvalidParams;
    std::string m_SupportedFeatures = "";
    AccessTokenErr m_AccessTokenError;
    AccessTokenReq m_AccessTokenRequest;
    std::string m_NrfId = "";
};

std::vector<ProblemDetails> createProblemDetailsVectorFromJsonString(const std::string& json);

template<>
inline boost::property_tree::ptree toPt<ProblemDetails>(const ProblemDetails& val) {
    return val.toPropertyTree();
}

template<>
inline ProblemDetails fromPt<ProblemDetails>(const boost::property_tree::ptree& pt) {
    ProblemDetails ret;
    ret.fromPropertyTree(pt);
    return ret;
}

}
}
}
}

#endif /* ProblemDetails_H_ */
